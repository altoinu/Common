/** * This Source Code Form is subject to the terms of the Mozilla Public * License, v. 2.0. If a copy of the MPL was not distributed with this file, * You can obtain one at http://mozilla.org/MPL/2.0/. *  * Copyright (c) 2014 Kaoru Kawashima @altoinu http://altoinu.com */package com.altoinu.flash.services{		import flash.display.Stage;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.net.URLRequest;	import flash.net.URLRequestHeader;	import flash.net.URLRequestMethod;	import flash.utils.ByteArray;	import flash.utils.Endian;		/**	 * Utility functions related to anything that has to do with net service (such as flash.net.*).	 * 	 * @author Kaoru Kawashima	 * 	 */	public class NetUtils	{				//--------------------------------------------------------------------------		//		//  Class variables		//		//--------------------------------------------------------------------------				//--------------------------------------		//  For NetUtils.bitmapDataURLRequest		//--------------------------------------				/**		 * Boundary used to break up different parts of the http POST body		 */		private static var _bitmapDataURLRequest_boundary:String = "";				//--------------------------------------------------------------------------		//		//  Private class methods		//		//--------------------------------------------------------------------------				//--------------------------------------		//  For NetUtils.bitmapDataURLRequest		//--------------------------------------				/**		 * Get the boundary for the post.		 * Must be passed as part of the contentType of the UrlRequest		 */		private static function bitmapDataURLRequest_getBoundary():String		{			if (_bitmapDataURLRequest_boundary.length == 0)			{								for (var i:int = 0; i < 0x20; i++ )				{										_bitmapDataURLRequest_boundary += String.fromCharCode( int( 97 + Math.random() * 25 ) );									}							}			return _bitmapDataURLRequest_boundary;					}				//--------------------------------------------------------------------------		//		//  Class methods		//		//--------------------------------------------------------------------------				/**		 * Author(s): Jonathan Dunlap		 * Returns True or False if the flash file is running locally.		 * 		 */		public static function isLocal(stage:Stage):Boolean		{						var search:RegExp = /file:\/\//i;			return search.test(stage.loaderInfo.url);					}				//--------------------------------------		//  Methods to create multipart/form-data		//--------------------------------------				private static function createRandomBoundary():String		{						var boundary:String = "";			for (var i:int = 0; i < 0x20; i++ )			{								boundary += String.fromCharCode( int( 97 + Math.random() * 25 ) );							}						return boundary;					}				private static function insertLineBreak(data:ByteArray):ByteArray		{						data.writeShort(0x0d0a);			return data;					}				private static function insertDoubleDash(data:ByteArray):ByteArray		{						data.writeShort(0x2d2d);			return data;					}				private static function insertQuotationMark(data:ByteArray):ByteArray		{						data.writeByte(0x22);			return data;					}				private static function insertBoundary(data:ByteArray, boundary:String):ByteArray		{						var boundaryLength:int = boundary.length;						insertDoubleDash(data);			for (var i:int = 0; i < boundaryLength; i++)			{								data.writeByte(boundary.charCodeAt(i));							}						return data;					}				private static function insertFilesAndParameters(data:ByteArray,boundary:String,														parameters:Object,autoDetermineFileType:Boolean=true):void		{						var fileName:String;			var fileCount:int = 0;			var fileData:ByteArray;						for (var name:String in parameters)			{								insertBoundary(data, boundary);				insertLineBreak(data);								if (parameters[name] is ByteArray || parameters[name] is NetUtilsFileObject)				{										data.writeUTFBytes('Content-Disposition: form-data; name="'+name+'"; filename="');										if (parameters[name] is ByteArray)					{												if(autoDetermineFileType)						{							fileName = "file" + fileCount + "." + determineFileType(parameters[name] as ByteArray);						}						else						{							fileName = "file" + fileCount;						}												fileData = parameters[name] as ByteArray;						fileCount++;											}					else if (parameters[name] is NetUtilsFileObject)					{												fileName = parameters[name].fileName;						fileData = parameters[name].byteArray;											}										data.writeUTFBytes(fileName + '"');					insertLineBreak(data);										data.writeUTFBytes('Content-Type: application/octet-stream');					insertLineBreak(data);					insertLineBreak(data);					data.writeBytes(fileData, 0, fileData.length); // contents of file										// end					insertLineBreak(data);									}				else				{										data.writeUTFBytes('Content-Disposition: form-data; name="' + name + '"');					// parameter value					insertLineBreak(data);					insertLineBreak(data);										if(parameters[name])						data.writeUTFBytes(parameters[name].toString()); // value of this parameter					// end					insertLineBreak(data);										}			}						insertBoundary(data,boundary);			insertDoubleDash(data);					}				private static function insertParameters(data:ByteArray, boundary:String,												 parameters:Object):ByteArray		{						var bytes:String;			var i:int;			var numBytesLength:int;						for (var name:String in parameters)			{								// boundary				insertBoundary(data, boundary);				insertLineBreak(data);								// parameter name				//bytes = 'Content-Disposition: form-data; name="' + name + '"';/*				numBytesLength = bytes.length;				for (i = 0; i < numBytesLength; i++)				{										data.writeByte(bytes.charCodeAt(i));									}*/								data.writeUTFBytes('Content-Disposition: form-data; name="' + name + '"');								// parameter value				insertLineBreak(data);				insertLineBreak(data);								if (!(parameters[name] is ByteArray))				{					data.writeUTFBytes(parameters[name]); // value of this parameter				}				else				{					data.writeBytes(parameters[name]);				}								// end				insertLineBreak(data);							}						return data;					}				private static function insertFileData(data:ByteArray, boundary:String,											   fileName:String,											   formFieldName:String,											   fileData:ByteArray):ByteArray		{						var bytes:String;			var i:int;			var numBytesLength:int;						// boundary			insertBoundary(data, boundary);			insertLineBreak(data);						// parameter name			bytes = 'Content-Disposition: form-data; name="'+formFieldName+'"; filename="';			numBytesLength = bytes.length;			for (i = 0; i < numBytesLength; i++)			{								data.writeByte(bytes.charCodeAt(i));							}			data.writeUTFBytes(fileName); // actual file name			insertQuotationMark(data);			insertLineBreak(data);						// parameter contents			bytes = 'Content-Type: application/octet-stream';			numBytesLength = bytes.length;			for (i = 0; i < numBytesLength; i++)			{								data.writeByte(bytes.charCodeAt(i));							}			insertLineBreak(data);			insertLineBreak(data);			data.writeBytes(fileData, 0, fileData.length); // contents of file						// end			insertLineBreak(data);						return data;					}				/**		 * Build multipart/form-data using single file.		 * 		 * <p>TODO: Multiple file form data? http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2</p>		 * 		 * @param fileName Name of the file.		 * @param formFieldName Parameter name on form to pass file data under.		 * @param fileData Contents of the file.		 * @param parameters Other name-value parameters to be included.		 * @return 		 * 		 */		public static function createSingleFileMultipartFormData(fileName:String,																 formFieldName:String,																 fileData:ByteArray,																 parameters:Object = null):ByteArray		{						var multipartFormData:ByteArray = new ByteArray();			multipartFormData.endian = Endian.BIG_ENDIAN;						if (parameters == null)				parameters = new Object();						// Filename			parameters.Filename = fileName;						// random boundary			var boundary:String = createRandomBoundary();						// Beginning of multipart form data			var bytes:String = "Content-Type: multipart/form-data; boundary=" + boundary;			var numBytesLength:int = bytes.length;			for (var i:int = 0; i < numBytesLength; i++)			{								multipartFormData.writeByte(bytes.charCodeAt(i));							}			insertLineBreak(multipartFormData);			insertLineBreak(multipartFormData);						// Body of multipart/form-data			insertParameters(multipartFormData, boundary, parameters); // parameters to form data			insertFileData(multipartFormData, boundary, fileName, formFieldName, fileData); // file data						// close boundary			insertBoundary(multipartFormData, boundary);			insertDoubleDash(multipartFormData);						return multipartFormData;					}				/**		 * Author(s): Kaoru Kawashima		 * 		 * <p>Creates an instance of URLRequest that can be used to upload one encoded BitmapData via form post.  This is similar to		 * FileReference but instead of letting user browse for image file to upload, any encoded BitmapData within Flash		 * can be uploaded.  Image encoders are available from com.altoinu.flash.images.* or as3corelib.</p>		 * 		 * <p>Before URLRequest created by this method is loaded with URLLoader, make sure URLLoader.dataFormat is set to URLLoaderDataFormat.BINARY		 * (ex. URLLoader.dataFormat = URLLoaderDataFormat.BINARY).</p>		 * 		 * @param uploadURL The URL where image is going to be uploaded to.		 * @param fileName File name to upload as.		 * @param imageParameterName Parameter name on form to pass BitmapData under.		 * @param image_byteArray Encoded BitmapData. Use encoders such as JPEGEncoder and PNGEncoder to convert BitmapData into		 * ByteArray first.		 * @param parameters Other name-value parameters to be passed.		 * @param requestHeaders Array of <code>URLRequestHeader</code> to be sent. By default (or by setting to null)		 * this method adds <code>new URLRequestHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;)</code>.		 * If no request header is desired, set this parameter to empty array [].		 * 		 * @return URLRequest containing BitmapData ByteArray to be uploaded.  Feed this into URLLoader.load(URLRequest) to start uploading.		 * 		 */		public static function bitmapDataURLRequest(uploadURL:String,													fileName:String,													imageParameterName:String,													image_byteArray:ByteArray,													parameters:Object = null,													requestHeaders:Array = null):URLRequest		{						var postData:ByteArray = new ByteArray();			postData.endian = Endian.BIG_ENDIAN;						//add Filename to parameters			if (parameters == null)				parameters = new Object();						parameters.Filename = fileName;						/*			// Add one linebreak			var __linebreak:Function = function(p:ByteArray):ByteArray			{								p.writeShort(0x0d0a);				return p;							}				// Add quotation mark			var __quotationmark:Function = function(p:ByteArray):ByteArray			{								p.writeByte(0x22);				return p;							}				// Add Double Dash			var __doubledash:Function = function(p:ByteArray):ByteArray			{								p.writeShort(0x2d2d);				return p;							}						// Add a boundary to the PostData with leading doubledash			var __boundary:Function = function(p:ByteArray):ByteArray			{								var l:int = bitmapDataURLRequest_getBoundary().length;					p = __doubledash(p);				for (var i:int = 0; i < l; i++ )				{										p.writeByte( _bitmapDataURLRequest_boundary.charCodeAt( i ) );									}				return p;							}						var i: int;			var bytes:String;						//add parameters to postData			for(var name:String in parameters)			{								postData = __boundary(postData);				postData = __linebreak(postData);				bytes = 'Content-Disposition: form-data; name="' + name + '"';				for ( i = 0; i < bytes.length; i++ )				{										postData.writeByte( bytes.charCodeAt(i) );									}				postData = __linebreak(postData);				postData = __linebreak(postData);				postData.writeUTFBytes(parameters[name]);				postData = __linebreak(postData);							}			//add Filedata to postData			postData = __boundary(postData);			postData = __linebreak(postData);			bytes = 'Content-Disposition: form-data; name="'+imageParameterName+'"; filename="';			for ( i = 0; i < bytes.length; i++ )			{								postData.writeByte( bytes.charCodeAt(i) );							}			postData.writeUTFBytes(fileName);			postData = __quotationmark(postData);			postData = __linebreak(postData);			bytes = 'Content-Type: application/octet-stream';			for ( i = 0; i < bytes.length; i++ ) {				postData.writeByte( bytes.charCodeAt(i) );			}			postData = __linebreak(postData);			postData = __linebreak(postData);			postData.writeBytes(image_byteArray, 0, image_byteArray.length);			postData = __linebreak(postData);			//add upload filed to postData			postData = __linebreak(postData);			postData = __boundary(postData);			postData = __linebreak(postData);			bytes = 'Content-Disposition: form-data; name="Upload"';			for ( i = 0; i < bytes.length; i++ )			{								postData.writeByte( bytes.charCodeAt(i) );							}			postData = __linebreak(postData);			postData = __linebreak(postData);			bytes = 'Submit Query';			for ( i = 0; i < bytes.length; i++ )			{								postData.writeByte( bytes.charCodeAt(i) );							}			postData = __linebreak(postData);			//closing boundary			postData = __boundary(postData);			postData = __doubledash(postData);						// Build URLRequest			var imageUploadURLRequest:URLRequest = new URLRequest(uploadURL);			imageUploadURLRequest.contentType = 'multipart/form-data; boundary=' + bitmapDataURLRequest_getBoundary();			imageUploadURLRequest.method = URLRequestMethod.POST;			*/						var boundary:String = createRandomBoundary();						// Body of multipart/form-data			insertParameters(postData, boundary, parameters);						if (image_byteArray != null)				insertFileData(postData, boundary, fileName, imageParameterName, image_byteArray);						// close boundary			insertBoundary(postData, boundary);			insertDoubleDash(postData);						// Build URLRequest			var imageUploadURLRequest:URLRequest = new URLRequest(uploadURL);			imageUploadURLRequest.contentType = "multipart/form-data; boundary=" + boundary;			imageUploadURLRequest.method = URLRequestMethod.POST;						if (requestHeaders == null)			{								// Default request header				imageUploadURLRequest.requestHeaders.push(new URLRequestHeader('Cache-Control', 'no-cache'));							}			else			{								// add specified request headers				var reqHeader:URLRequestHeader;				var numHeaders:int = requestHeaders.length;				for (var reqIndex:int = 0; reqIndex < numHeaders; reqIndex++)				{										try					{												reqHeader = requestHeaders[reqIndex];						imageUploadURLRequest.requestHeaders.push(reqHeader);											}					catch (e:Error)					{											}									}							}						imageUploadURLRequest.data = postData;						return imageUploadURLRequest;					}		/**		 * 		 * <p>Creates an instance of URLRequest that can be used to upload one encoded BitmapData via form post.  This is similar to		 * FileReference but instead of letting user browse for image file to upload, any encoded BitmapData within Flash		 * can be uploaded.  Image encoders are available from com.altoinu.flash.images.* or as3corelib.</p>		 * 		 * <p>Before URLRequest created by this method is loaded with URLLoader, make sure URLLoader.dataFormat is set to URLLoaderDataFormat.BINARY		 * (ex. URLLoader.dataFormat = URLLoaderDataFormat.BINARY).</p>		 * 		 * @param uploadURL The URL where image is going to be uploaded to.		 * @param fileNames Array of filenames for each image that is uploaded. The array length needs to match those of imageParameterNames and image_byteArrays.		 * @param imageParameterNames Parameter names on form to pass each BitmapData under. The array length needs to match those of fileNames and image_byteArrays.		 * @param image_byteArrays Encoded BitmapData array. The array length needs to match those of imageParameterNames and fileNames. Use encoders such as JPEGEncoder and PNGEncoder to convert BitmapData into		 * ByteArray first.		 * @param parameters Other name-value parameters to be passed.		 * @return URLRequest containing all BitmapData ByteArrays to be uploaded.  Feed this into URLLoader.load(URLRequest) to start uploading.		 * 		 */		public static function multipleBitmapDataURLRequest(uploadURL:String, fileNames:Array, imageParameterNames:Array, image_byteArrays:Array, parameters:Object = null):URLRequest		{						// Add one linebreak			var __linebreak:Function = function(p:ByteArray):ByteArray			{								p.writeShort(0x0d0a);				return p;							}				// Add quotation mark			var __quotationmark:Function = function(p:ByteArray):ByteArray			{								p.writeByte(0x22);				return p;							}				// Add Double Dash			var __doubledash:Function = function(p:ByteArray):ByteArray			{								p.writeShort(0x2d2d);				return p;							}						// Add a boundary to the PostData with leading doubledash			var __boundary:Function = function(p:ByteArray):ByteArray			{								var l:int = bitmapDataURLRequest_getBoundary().length;					p = __doubledash(p);				for (var i:int = 0; i < l; i++ )				{										p.writeByte( _bitmapDataURLRequest_boundary.charCodeAt( i ) );									}				return p;							}						var i: int;			var bytes:String;						var postData:ByteArray = new ByteArray();			postData.endian = Endian.BIG_ENDIAN;						//add Filename to parameters			if(parameters == null)				parameters = new Object();						parameters.Filename = fileNames[0];						//add parameters to postData			for(var name:String in parameters)			{								postData = __boundary(postData);				postData = __linebreak(postData);				bytes = 'Content-Disposition: form-data; name="' + name + '"';				for ( i = 0; i < bytes.length; i++ )				{										postData.writeByte( bytes.charCodeAt(i) );									}				postData = __linebreak(postData);				postData = __linebreak(postData);				postData.writeUTFBytes(parameters[name]);				postData = __linebreak(postData);							}			for(var j:uint = 0;j<fileNames.length;j++)			{				//add Filedata to postData				postData = __boundary(postData);				postData = __linebreak(postData);					bytes = 'Content-Disposition: form-data; name="'+imageParameterNames[j]+'"; filename="';				for ( i = 0; i < bytes.length; i++ )				{										postData.writeByte( bytes.charCodeAt(i) );									}				postData.writeUTFBytes(fileNames[j]);				postData = __quotationmark(postData);				postData = __linebreak(postData);				bytes = 'Content-Type: application/octet-stream';				for ( i = 0; i < bytes.length; i++ ) {					postData.writeByte( bytes.charCodeAt(i) );				}				postData = __linebreak(postData);				postData = __linebreak(postData);				postData.writeBytes(image_byteArrays[j], 0, image_byteArrays[j].length);				postData = __linebreak(postData);			}						//add upload filed to postData			postData = __linebreak(postData);			postData = __boundary(postData);			postData = __linebreak(postData);			bytes = 'Content-Disposition: form-data; name="Upload"';			for ( i = 0; i < bytes.length; i++ )			{								postData.writeByte( bytes.charCodeAt(i) );							}			postData = __linebreak(postData);			postData = __linebreak(postData);			bytes = 'Submit Query';			for ( i = 0; i < bytes.length; i++ )			{								postData.writeByte( bytes.charCodeAt(i) );							}			postData = __linebreak(postData);			//closing boundary			postData = __boundary(postData);			postData = __doubledash(postData);						// Build URLRequest			var imageUploadURLRequest:URLRequest = new URLRequest(uploadURL);			imageUploadURLRequest.contentType = 'multipart/form-data; boundary=' + bitmapDataURLRequest_getBoundary();			imageUploadURLRequest.method = URLRequestMethod.POST;			imageUploadURLRequest.requestHeaders.push(new URLRequestHeader('Cache-Control', 'no-cache'));			imageUploadURLRequest.data = postData;						return imageUploadURLRequest;					}		private static function compareBytes(byteArray:ByteArray,... byteValues):Boolean		{						if (!byteValues)				return false;			for (var i:int = 0; i < byteValues.length; i++)			{								if (byteArray[i] != byteValues[i])					return false;							}						return true;					}				public static function determineFileType(bytes:ByteArray):String		{						if (compareBytes(bytes,0xFF,0xD8))			{				return "jpg";			}			else if (compareBytes(bytes,0x49,0x49,0x2A))			{				return "tif";			}			else if (compareBytes(bytes,0x42,0x4D))			{				return "bmp";			}			else if (compareBytes(bytes,0x47,0x49,0x46))			{				return "gif";			}			else if (compareBytes(bytes,0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a))			{				return "png";			}						return "";						}						/**		 *	Creates a URLRequest with encoding type as multipart/form-data. The parameters object can contain any object that can		 * be converted to a string (using toString()), a ByteArray, or a NetUtilsFileObject.  		 * @param uploadURL The url to post to		 * @param parameters An object that contains all parameters to be passed. The post variable names will be the		 * property names of this object, and the post values will be the values of those properties.		 * @param requestHeaders Array of <code>URLRequestHeader</code> to be sent. By default (or by setting to null)		 * this method adds <code>new URLRequestHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;)</code>.		 * If no request header is desired, set this parameter to empty array []. If you are getting some kind of security		 * due to crossdomain... try setting this to []. Sometimes it fixes.		 * @param autoDetermineFileType If set to true, any ByteArray in the parameters object will have its file type is determined		 * by <code>determineFileType</code>. If set to false, any ByteArray will not have an file extension.		 * @return URLRequest containing all paramters		 *  		 */				public static function createMultipartFormDataURLRequest(uploadURL:String,parameters:Object,requestHeaders:Array=null,autoDetermineFileType:Boolean=true):URLRequest		{			var postData:ByteArray = new ByteArray();			postData.endian = Endian.BIG_ENDIAN;						//add Filename to parameters			if (parameters == null)				parameters = new Object();									var boundary:String = createRandomBoundary();						// Body of multipart/form-data			insertFilesAndParameters(postData, boundary, parameters,autoDetermineFileType);									// Build URLRequest			var rtrn:URLRequest = new URLRequest(uploadURL);			rtrn.contentType = "multipart/form-data; boundary=" + boundary;			rtrn.method = URLRequestMethod.POST;						if (requestHeaders == null)			{								// Default request header				rtrn.requestHeaders.push(new URLRequestHeader('Cache-Control', 'no-cache'));							}			else			{								// add specified request headers				var reqHeader:URLRequestHeader;				var numHeaders:int = requestHeaders.length;				for (var reqIndex:int = 0; reqIndex < numHeaders; reqIndex++)				{										try					{												reqHeader = requestHeaders[reqIndex];						rtrn.requestHeaders.push(reqHeader);											}					catch (e:Error)					{											}									}							}						rtrn.data = postData;						return rtrn;		}				/**		 * Author(s): Kaoru Kawashima		 * 		 * <p>Uploads ByteArray of BitmapData to specified URL using form post.</p>		 * 		 * @param uploadURL The URL where image is going to be uploaded to.		 * @param fileName File name to upload as.		 * @param imageParameterName Parameter name on form to pass BitmapData under.		 * @param image_byteArray Encoded BitmapData to be uploaded. Use encoders such as JPEGEncoder and PNGEncoder to convert BitmapData into		 * ByteArray first.		 * @param parameters Other name-value parameters to be passed.		 * @param requestHeaders Array of <code>URLRequestHeader</code> to be sent. By default (or by setting to null)		 * this method adds <code>new URLRequestHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;)</code>.		 * If no request header is desired, set this parameter to empty array []. If you are getting some kind of security		 * due to crossdomain... try setting this to []. Sometimes it fixes.		 * 		 * @return URLLoader handling the uploading.		 * 		 */		public static function uploadImage(uploadURL:String,										   fileName:String,										   imageParameterName:String,										   image_byteArray:ByteArray,										   parameters:Object = null,										   requestHeaders:Array = null):URLLoader		{						var uploadURLLoader:URLLoader = new URLLoader();			uploadURLLoader.dataFormat = URLLoaderDataFormat.BINARY;						uploadURLLoader.load(bitmapDataURLRequest(uploadURL, fileName, imageParameterName, image_byteArray, parameters, requestHeaders));						return uploadURLLoader;					}				/**		 * <p>Uploads ByteArrays of BitmapData to specified URL using form post.</p>		 * 		 * @param uploadURL The URL where image is going to be uploaded to.		 * @param fileNames Array of filenames for each image that is uploaded. The array length needs to match those of imageParameterNames and image_byteArrays.		 * @param imageParameterNames Parameter names on form to pass each BitmapData under. The array length needs to match those of fileNames and image_byteArrays.		 * @param image_byteArrays Encoded BitmapData array. The array length needs to match those of imageParameterNames and fileNames. Use encoders such as JPEGEncoder and PNGEncoder to convert BitmapData into		 * ByteArray first.		 * @param parameters Other name-value parameters to be passed.		 * @return URLLoader handling the uploading.		 * 		 */		public static function uploadMultipleImages(uploadURL:String,fileNames:Array,imageParameterNames:Array,image_byteArrays:Array,parameters:Object=null):URLLoader		{						var uploadURLLoader:URLLoader = new URLLoader();			uploadURLLoader.dataFormat = URLLoaderDataFormat.BINARY;						uploadURLLoader.load(multipleBitmapDataURLRequest(uploadURL, fileNames, imageParameterNames, image_byteArrays, parameters));						return uploadURLLoader;					}				//--------------------------------------------------------------------------		//		//  Constructor		//		//--------------------------------------------------------------------------				/** 		 * Constructor.  You do not create an instance of this class... just call its static functions		 */		public function NetUtils()		{						throw("You do not create an instance of NetUtils.  Just call its static functions.");					}			}	}