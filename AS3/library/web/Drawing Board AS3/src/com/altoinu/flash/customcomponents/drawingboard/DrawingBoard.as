/** * This Source Code Form is subject to the terms of the Mozilla Public * License, v. 2.0. If a copy of the MPL was not distributed with this file, * You can obtain one at http://mozilla.org/MPL/2.0/. *  * Copyright (c) 2014 Kaoru Kawashima @altoinu http://altoinu.com */package com.altoinu.flash.customcomponents.drawingboard{		import com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent;	import com.altoinu.flash.customcomponents.drawingboard.events.ImageSelectionToolEvent;	import com.altoinu.flash.customcomponents.drawingboard.imageEditTools.proto.Image_SelectionTool;		import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;
		//--------------------------------------	//  Events	//--------------------------------------		/**	 *  Dispatched when image on the <code>DrawingBoard</code> or any of the <code>DrawingLayer</code> in it changes.	 *	 *  @eventType com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent.IMAGE_UPDATED	 */	[Event(name="imageUpdated", type="com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent")]		/**	 *  Dispatched when Image_SelectionTool's transformation is updated on the <code>DrawingBoard</code> or any of the <code>DrawingLayer</code> in it.	 *	 *  @eventType com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent.IMAGE_SELECTION_UPDATED	 */	[Event(name="imageSelectionUpdated", type="com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent")]		/**	 *  Dispatched when image is drawn on to the <code>DrawingBoard</code> or any of the <code>DrawingLayer</code> in it.	 *	 *  @eventType com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent.DRAW	 */	[Event(name="draw", type="com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent")]		/**	 *  Dispatched when a single image/element is cleared from <code>DrawingBoard</code> or any of the <code>DrawingLayer</code>	 * in it. Unlike "erase" event, this event is dispatched every time something is removed. Use <code>erase</code> event to	 * listen for erase operation to complete.	 *	 *  @eventType com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent.IMAGE_REMOVED	 */	[Event(name="imageRemoved", type="com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent")]		/**	 *  Dispatched when image is erased from the <code>DrawingBoard</code> or any of the <code>DrawingLayer</code> in it.	 *	 *  @eventType com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent.ERASE	 */	[Event(name="erase", type="com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent")]		/**	 *  Dispatched when image is grabbed by mouse to be dragged.	 *	 *  @eventType com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent.MOUSE_GRAB	 */	[Event(name="mouseGrab", type="com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent")]		/**	 *  Dispatched when image is dropped on to <code>DrawingBoard</code> from mouse dragging.	 *	 *  @eventType com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent.MOUSE_DROP	 */	[Event(name="mouseDrop", type="com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent")]		/**	 *  Dispatched when image is dropped, but did not get placed on <code>DrawingBoard</code>.	 *	 *  @eventType com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent.MOUSE_DROP_MISS	 */	[Event(name="mouseDropMiss", type="com.altoinu.flash.customcomponents.drawingboard.events.DrawingBoardEvent")]		/**	 *  Dispatched when an image is selected by <code>selectTool</code>.	 *	 *  @eventType com.altoinu.flash.customcomponents.drawingboard.events.ImageSelectionToolEvent.SELECT	 */	[Event(name="select", type="com.altoinu.flash.customcomponents.drawingboard.events.ImageSelectionToolEvent")]		/**	 *  Dispatched when an image is deselected.	 *	 *  @eventType com.altoinu.flash.customcomponents.drawingboard.events.ImageSelectionToolEvent.DESELECT	 */	[Event(name="deselect", type="com.altoinu.flash.customcomponents.drawingboard.events.ImageSelectionToolEvent")]		/**	 * Main movieclip class which will hold multiple <code>DrawingLayers</code> to	 * represent one single image.	 * 	 * <p>The main purpose of <code>DrawingBoard</code> is layer management.  You cannot add <code>DisplayObject</code>	 * unless it is a <code>DrawingLayer</code>.  To add place an image, you first create a new instance of	 * <code>DrawingLayer</code>, add it to the <code>DrawingBoard</code>, then add images into that	 * <code>DrawingLayer</code>.</p>	 *	 * @author Kaoru Kawashima	 */	public class DrawingBoard extends MovieClip implements IDrawingBoard	{				//--------------------------------------------------------------------------		//		//  Class constants		//		//--------------------------------------------------------------------------				public static const DEFAULT_CANVAS_WIDTH:Number = 640;		public static const DEFAULT_CANVAS_HEIGHT:Number = 480;				//--------------------------------------------------------------------------		//		//  Contructor		//		//--------------------------------------------------------------------------				/**		 * Constructor.		 * 		 * @param canvasWidth Width of the canvas.  Default is 640.		 * @param canvasHeight Height of the canvas.  Default is 480.		 * 		 */		public function DrawingBoard(canvasWidth:Number = NaN, canvasHeight:Number = NaN)		{						super();						// Remember the canvas size			if (isNaN(canvasWidth))				canvasWidth = DEFAULT_CANVAS_WIDTH;			if (isNaN(canvasHeight))				canvasHeight = DEFAULT_CANVAS_HEIGHT;			_canvasSize = new Rectangle(0, 0, (width > 0 ? width : canvasWidth), (height > 0 ? height : canvasHeight));						trace("Initialize drawing board "+this);						// Remove everything that is not DrawingLayer			var removeTargets:Array = new Array();			for (var i:Number = 0; i < numChildren; i++)			{								// Remove everything that is not a drawing layer				if (!(getChildAt(i) is DrawingLayer))					removeTargets.push(getChildAt(i));							}						var numRemoveTargets:int = removeTargets.length;			for (i = 0; i < numRemoveTargets; i++)			{								super.removeChild(removeTargets[i]);							}					}				//--------------------------------------------------------------------------		//		//  Variables		//		//--------------------------------------------------------------------------				private var newElementToBeDropped:Sprite;		private var somethingWasJustSelectedWithMouse:Boolean = false;		private var forceDraw:Boolean = false;				//--------------------------------------------------------------------------		//		//  Properties defined by IDrawingBoard		//		//--------------------------------------------------------------------------				//----------------------------------		//  selectMode		//----------------------------------				private var _selectMode:Boolean = false;				[Bindable]		/**		 * @copy com.altoinu.flash.customcomponents.drawingboard.IDrawingBoard#selectMode		 */				public function get selectMode():Boolean		{						return _selectMode;					}				/**		 * @private		 */		public function set selectMode(value:Boolean):void		{						if (_selectMode != value)			{								_selectMode = value;								setLayerMouseState();							}					}				//----------------------------------		//  selectTool		//----------------------------------				private var _selectTool:Image_SelectionTool = new Image_SelectionTool();;				[Bindable(event="selectToolChange")]		/**		 * @copy com.altoinu.flash.customcomponents.drawingboard.IDrawingBoard#selectTool		 */		public function get selectTool():Image_SelectionTool		{						return _selectTool;					}				/**		 * @private		 */		public function set selectTool(newTool:Image_SelectionTool):void		{						// Remember what has been already selected			var currentSelectedTarget:DisplayObject;			if (_selectTool != null)			{								_selectTool.removeEventListener(ImageSelectionToolEvent.SELECT, onImageSelect);				_selectTool.removeEventListener(ImageSelectionToolEvent.DESELECT, onImageSelect);				currentSelectedTarget = _selectTool.target;				_selectTool.target = null;							}						_selectTool = newTool;						// Reselect what has been already selected			if (_selectTool != null)			{								_selectTool.addEventListener(ImageSelectionToolEvent.SELECT, onImageSelect);				_selectTool.addEventListener(ImageSelectionToolEvent.DESELECT, onImageSelect);				_selectTool.target = currentSelectedTarget;							}						dispatchEvent(new Event("selectToolChange"));					}				//----------------------------------		//  selectedLayerIndex		//----------------------------------				private var __selectedLayerIndex:int = -1;				private function get _selectedLayerIndex():int		{						return __selectedLayerIndex;					}				/**		 * @private		 */		private function set _selectedLayerIndex(value:int):void		{						if (selectedLayer != null)				selectedLayer.removeEventListener(MouseEvent.MOUSE_DOWN, onLayerClickSelectItem);						__selectedLayerIndex = value;						setLayerMouseState();						if (selectedLayer != null)				selectedLayer.addEventListener(MouseEvent.MOUSE_DOWN, onLayerClickSelectItem); // Event to handle selection					}				/**		 * @copy com.altoinu.flash.customcomponents.drawingboard.IDrawingBoard#selectedLayerIndex		 * 		 * @default -1;		 */		public function get selectedLayerIndex():int		{						return _selectedLayerIndex;					}				/**		 * @private		 */		public function set selectedLayerIndex(value:int):void		{						var allLayers:Vector.<IDrawingLayer> = getDrawingLayers();						if ((((allLayers == null) || (allLayers.length == 0)) && (value == -1)) ||				((allLayers != null) && (-1 <= value) && (value < allLayers.length)))			{								// No layers exist in DrawingBoard but specified value is -1 (no layer selected) or				// Layers exist, and layer index is within the range or -1 (null)				_selectedLayerIndex = value;							}			else			{								throw new Error("Specified selectedLayerIndex is out of range.");							}					}				//----------------------------------		//  selectedLayer		//----------------------------------				/**		 * @copy com.altoinu.flash.customcomponents.drawingboard.IDrawingBoard#selectedLayer		 * 		 * @default null		 */		public function get selectedLayer():IDrawingLayer		{						var allLayers:Vector.<IDrawingLayer> = getDrawingLayers();						if ((allLayers != null) && (allLayers.length > 0) && (0 <= _selectedLayerIndex) && (_selectedLayerIndex < allLayers.length))				return allLayers[_selectedLayerIndex]; // return layer at specified index			else				return null; // specified layer index does not exist, null					}				/**		 * @private		 */		public function set selectedLayer(targetLayer:IDrawingLayer):void		{						var allLayers:Vector.<IDrawingLayer> = getDrawingLayers();						if (targetLayer == null)				_selectedLayerIndex = -1; // no selection, -1			else if ((allLayers != null) && (getLayerIndex(targetLayer) != -1))				_selectedLayerIndex = getLayerIndex(targetLayer); // layer exists, remember that index			else				throw new Error("Specified layer is not part of the DrawingBoard.");					}				//----------------------------------		//  canvasSize		//----------------------------------				private var _canvasSize:Rectangle;				/**		 * @copy com.altoinu.flash.customcomponents.drawingboard.IDrawingBoard#canvasSize		 */		public function get canvasSize():Rectangle		{						return _canvasSize;					}				//--------------------------------------------------------------------------		//		//  Properties		//		//--------------------------------------------------------------------------				//----------------------------------		//  drawingLayers		//----------------------------------				/**		 * Gets array of <code>DrawingLayers</code> currently on the <code>DrawingBoard</code>.		 */		public function get drawingLayers():Vector.<IDrawingLayer>		{						return getDrawingLayers();					}				//----------------------------------		//  imageMouseDragEnabled		//----------------------------------				private var _imageMouseDragEnabled:Boolean = false;				/**		 * If set to true, then non-bitmap elements placed on <code>DrawingBoard</code> can be dragged		 * using mouse. Only effective when <code>selectMode == true</code>.		 * 		 * @default false		 */		public function get imageMouseDragEnabled():Boolean		{						return _imageMouseDragEnabled;					}				/**		 * @private		 */		public function set imageMouseDragEnabled(value:Boolean):void		{						if (imageMouseDragEnabled != value)			{								_imageMouseDragEnabled = value;								if (imageMouseDragEnabled)				{										// add listeners to handle mouse event					this.addEventListener(MouseEvent.MOUSE_DOWN, drawArea_mouseDownHandler);					this.addEventListener(MouseEvent.MOUSE_UP, drawArea_mouseUpHandler);					this.addEventListener(MouseEvent.MOUSE_MOVE, drawArea_mouseMoveHandler);									}				else				{										this.removeEventListener(MouseEvent.MOUSE_DOWN, drawArea_mouseDownHandler);					this.removeEventListener(MouseEvent.MOUSE_UP, drawArea_mouseUpHandler);					this.removeEventListener(MouseEvent.MOUSE_MOVE, drawArea_mouseMoveHandler);									}							}					}				//--------------------------------------------------------------------------		//		//  Overridden methods		//		//--------------------------------------------------------------------------				override public function toString():String		{						return "[object DrawingBoard]: canvas size "+_canvasSize.width+"x"+_canvasSize.height;					}				/**		 * Adds new drawing layer at the top level.  <code>addChild</code> function is overridden to prevent		 * anything other than DrawingLayer from being placed on the DrawingBoard.		 * 		 * @param item instance to be added to the DrawingBoard.  If it is not drawingLayer then nothing will		 * happen.		 * 		 * @return The DisplayObject instance that you pass in the <code>item</code> parameter.		 */		override public function addChild(item:DisplayObject):DisplayObject		{						return addChildAt(item, numChildren);					}				/**		 * Adds new drawing layer at specified index.  <code>addChildAt</code> function is overridden to prevent		 * anything other than DrawingLayer from being placed on the DrawingBoard.		 *		 * @param item instance to be added to the DrawingBoard.  If it is not drawingLayer then nothing will happen.		 * @param index Index number where drawingLayer will be added to.		 * 		 * @throws ArgumentError if <code>item</code> is not a DrawingLayer.		 * 		 * @return The DisplayObject instance that you pass in the <code>item</code> parameter.		 */		override public function addChildAt(item:DisplayObject, index:int):DisplayObject		{						if (item is IDrawingLayer)				addLayerAt(item as IDrawingLayer, index);			else				throw new Error("Only IDrawingLayer can be added to DrawingBoard.");						return item;					}				override public function removeChild(child:DisplayObject):DisplayObject		{						if (child is IDrawingLayer)				removeLayer(child as IDrawingLayer);			else				throw new Error("Only IDrawingLayer can be removed from DrawingBoard.");						return child;					}				override public function removeChildAt(index:int):DisplayObject		{						return removeLayerAt(index) as DisplayObject;					}				//--------------------------------------------------------------------------		//		//  Methods defined by IDrawingBoard		//		//--------------------------------------------------------------------------				/**		 * @copy com.altoinu.flash.customcomponents.drawingboard.IDrawingBoard#addLayer()		 */		public function addLayer(drawingLayer:IDrawingLayer):IDrawingLayer		{						return addLayerAt(drawingLayer, getDrawingLayers().length);					}				/**		 * @copy com.altoinu.flash.customcomponents.drawingboard.IDrawingBoard#addLayerAt()		 */		public function addLayerAt(drawingLayer:IDrawingLayer, index:int):IDrawingLayer		{						if (drawingLayer != null)			{								var addedNewLayer:IDrawingLayer;				var allLayers:Vector.<IDrawingLayer> = getDrawingLayers();								if ((index < 0) || (allLayers.length < index))				{										throw new Error("Specified layer index is out of range.");									}				else				{										// In case drawingLayer is on another DrawingBoard, remove it first					if (drawingLayer.parentDrawingBoard != null)						drawingLayer.parentDrawingBoard.removeLayer(drawingLayer);										if (index < allLayers.length)					{												var currentSelectedLayer:IDrawingLayer = selectedLayer; // remember currently selected layer												// Add drawingLayer at where current layer at specified index is						var currentDrawingLayerAtIndex:IDrawingLayer = allLayers[index];						var currentDrawingLayerAtIndexRealPos:int = getChildIndex(currentDrawingLayerAtIndex as DisplayObject);						addedNewLayer = super.addChildAt(drawingLayer as DisplayObject, currentDrawingLayerAtIndexRealPos) as IDrawingLayer;												// In case selectedLayer's position changed, update selectedLayerIndex						if (currentSelectedLayer != null)							__selectedLayerIndex = getLayerIndex(currentSelectedLayer);											}					else					{												// Add layer to top						addedNewLayer = super.addChild(drawingLayer as DisplayObject) as IDrawingLayer;											}										// Have drawingLayer remember reference to this DrawingBoard					addedNewLayer.parentDrawingBoard = this;										dispatchEvent(new DrawingBoardEvent(DrawingBoardEvent.IMAGE_UPDATED, false, false, null, null, addedNewLayer));									}								return addedNewLayer;							}			else			{								return null;							}					}				/**		 * @copy com.altoinu.flash.customcomponents.drawingboard.IDrawingBoard#addLayers()		 */		public function addLayers(drawingLayerArray:Array):Array		{						var addedLayers:Array;						if (drawingLayerArray != null)			{								for (var i:Number = 0; i < drawingLayerArray.length; i++)				{										if (drawingLayerArray[i] is DrawingLayer)					{												// This is a layer.  Add it to DrawingBoard						if (addedLayers == null)							addedLayers = [];												addedLayers.push(addLayer(drawingLayerArray[i]));											}									}							}						if (addedLayers != null)				dispatchEvent(new DrawingBoardEvent(DrawingBoardEvent.IMAGE_UPDATED, false, false, null, null, addedLayers[0]));						return addedLayers;					}				/**		 * @copy com.altoinu.flash.customcomponents.drawingboard.IDrawingBoard#removeLayer()		 */		public function removeLayer(drawingLayer:IDrawingLayer):IDrawingLayer		{						if (drawingLayer != null)			{								var wasSelectedLayer:Boolean = (drawingLayer == selectedLayer);								// Remove layer				var removedLayer:IDrawingLayer = super.removeChild(drawingLayer as DisplayObject) as IDrawingLayer;								// Make it forget reference to this DrawingBoard				removedLayer.parentDrawingBoard = null;								if (wasSelectedLayer)					selectedLayer = null; // Deselect if it selectedLayer was removed								dispatchEvent(new DrawingBoardEvent(DrawingBoardEvent.IMAGE_UPDATED, false, false, null, null, removedLayer));								return removedLayer;							}			else			{								return null;							}					}				/**		 * @copy com.altoinu.flash.customcomponents.drawingboard.IDrawingBoard#removeLayerAt()		 */		public function removeLayerAt(layerIndex:int):IDrawingLayer		{						return removeLayer(getDrawingLayers()[layerIndex]);					}				/**		 * @copy com.altoinu.flash.customcomponents.drawingboard.IDrawingBoard#getDrawingLayers()		 */		public function getDrawingLayers():Vector.<IDrawingLayer>		{						var layers:Vector.<IDrawingLayer> = new Vector.<IDrawingLayer>();						for (var i:int = 0; i < numChildren; i++)			{								if (getChildAt(i) is IDrawingLayer)					layers.push(getChildAt(i) as IDrawingLayer);							}						return layers;					}				/**		 * @copy com.altoinu.flash.customcomponents.drawingboard.IDrawingBoard#getLayerIndex()		 */		public function getLayerIndex(drawingLayer:IDrawingLayer):int		{						var layerNumber:int = -1;  // assume that layer does not exist			var drawingBoardItems:Vector.<IDrawingLayer> = getDrawingLayers();			var numLayers:int = drawingBoardItems.length;						for (var i:Number = 0; i < numLayers; i++)			{								if (drawingBoardItems[i] == drawingLayer)				{										// Found the layer in this drawing board					layerNumber = i;					break;									}							}						return layerNumber;					}				/** 		 * Clears drawng board by removing all layers.		 *		 * @return Array of removed layers.		 */		public function clearContents():Vector.<IDrawingLayer>		{						// Deselect layer			selectedLayerIndex = -1;						var layers:Vector.<IDrawingLayer> = getDrawingLayers();			var numLayers:int = layers.length;			if ((layers != null) && (numLayers > 0))			{								for (var i:Number = 0; i < numLayers; i++)				{										removeLayer(layers[i]);									}							}						if (layers.length > 0)				dispatchEvent(new DrawingBoardEvent(DrawingBoardEvent.IMAGE_UPDATED, false, false, null, null, layers[0]));						return layers;					}				/**		 * Get array of DisplayObjects currently on the DrawingBoard.		 *		 * @return Array of DisplayObjects.  i+1th element is on top of ith element.		 */		public function getChildren():Array		{						var childArray:Array;						if (numChildren > 0)			{								if (childArray == null)					childArray = [];								for (var i:int = 0; i < numChildren; i++)					childArray.push(getChildAt(i));							}						return childArray;					}				//--------------------------------------------------------------------------		//		//  Methods defined by IDrawable		//		//--------------------------------------------------------------------------				/**		 * Place drawing item on <code>selectedLayer</code> of the drawing board.  This method is accessed by DrawingTool		 * to place images on the specified <code>DrawingLayer</code>. If <code>selectedLayer == null</code>, this method		 * will automatically either choose top most layer or create a new layer and select it.		 * 		 * <p>This function has no effect if <code>selectMode</code> is set to true.</p>		 *		 * @param drawingItem Item to be placed on the drawing board.		 * @param xLoc x coordinate to place drawing item at.		 * @param yLoc y coordinate to place drawing item at.		 * @param zLoc z, which is the order of placement.  i+1th element will be on top of ith element.  If set to &lt; 0, then the 		 * drawingItem will be placed on top of existing DisplayObjects.		 *		 * @return Reference to the new drawing item.		 */		public function drawItemAt(drawingItem:DisplayObject, xLoc:Number = 0, yLoc:Number = 0, zLoc:Number = -1):DisplayObject		{						if (!selectMode || forceDraw)			{								if (selectedLayer == null)					createNewLayerAndSelectIt(); // If no selectedLayer								var currentSelectMode:Boolean = _selectMode;				if (forceDraw)					_selectMode = false; // If forceDraw, temporarily turn off select mode so selectedLayer can draw				selectedLayer.drawItemAt(drawingItem, xLoc, yLoc, zLoc); // Place image into selectedLayer				_selectMode = currentSelectMode;								// These events will be fired from selectedLayer				//dispatchEvent(new DrawingBoardEvent(DrawingBoardEvent.IMAGE_UPDATED, false, false, drawingItem, null, selectedLayer));				//dispatchEvent(new DrawingBoardEvent(DrawingBoardEvent.DRAW, false, false, drawingItem, null, selectedLayer, new Point(xLoc, yLoc)));							}						return drawingItem;					}				/**		 * Adds drawing item in front of existing images in this layer at coordinate 0, 0.		 * This method is accessed by DrawingTool to place images on the specified <code>DrawingLayer</code>.		 * 		 * <p>This function has no effect if <code>selectMode</code> is set to true.</p>		 *		 * @param drawingItem Drawing item to be placed on the drawing board.		 *		 * @return Reference to the new drawing item.		 */		public function drawItem(drawingItem:DisplayObject):DisplayObject		{						return drawItemAt(drawingItem, 0, 0, -1);					}				/**		 * Erases (removeChild) drawing item(s) on <code>selectedLayer</code> that are within erasing area defined by parameters.		 * Any <code>DisplayObject</code> that is within the specified area will be removed. If <code>selectedLayer == null</code>,		 * this method will automatically either choose top most layer or create a new layer and select it.		 * 		 * <p>If <code>DisplayObject</code> that is within the specified area is a <code>Bitmap</code> and if		 * <code>eraseShape</code> is defined, then the that <code>DisplayObject</code> gets pixels		 * that overlap <code>eraseShape</code> set to transparent (alpha=0) instead of entire Bitmap being		 * removed right away (entire Bitmap is removed if all pixels have become transparent).  This way, complex		 * shaped eraser can be used.</p>		 * 		 * <p>This function has no effect if it is not added to any <code>DrawingBoard</code> or		 * <code>selectMode</code> property of the <code>DrawingBoard</code> is set to true.</p>		 * 		 * @param xLoc x coordinate of the erasing area (Left edge).		 * @param yLoc y coordinate of the erasing area (Top edge).		 * @param eraseAreaWidth Width of the erasing area.		 * @param eraseAreaHeight Height of the erasing area.		 * @param eraseShape Shape of the eraser.  This is only effective on drawing images that are Bitmap.		 * 		 * @return Object containing two Arrays, Object.bitmaps which contains Bitmaps affected by this operation		 * and Object.nonBitmaps which contains non-Bitmaps removed.		 */		public function eraseItemsAt(xLoc:Number, yLoc:Number, eraseAreaWidth:Number = 0, eraseAreaHeight:Number = 0, eraseShape:Class = null):Object		{						var erasedItems:Object = new Object();			erasedItems.bitmaps = [];			erasedItems.nonBitmaps = [];						if (!selectMode)			{								if (selectedLayer == null)					createNewLayerAndSelectIt(); // If no selectedLayer								// Erase images on selectedLayer				erasedItems = selectedLayer.eraseItemsAt(xLoc, yLoc, eraseAreaWidth, eraseAreaHeight, eraseShape);								/* These events will be fired from selectedLayer				if ((erasedItems.bitmaps.length > 0) || (erasedItems.nonBitmaps.length > 0))				{										// and dispatch events					dispatchEvent(new DrawingBoardEvent(DrawingBoardEvent.IMAGE_UPDATED, false, false, null, erasedItems, selectedLayer));					dispatchEvent(new DrawingBoardEvent(DrawingBoardEvent.ERASE, false, false, null, erasedItems, selectedLayer, new Point(xLoc, yLoc)));									}				*/							}						return erasedItems;					}				//--------------------------------------------------------------------------		//		//  Methods for mouse interaction		//		//--------------------------------------------------------------------------				/**		 * Starts mouse grab and drop process. Grabbed item is dragged by mouse, and if it		 * is let go above <code>DrawingBoard</code> it is placed.		 * 		 * @param targetItem Object to be grabbed and dragged by mouse.		 * 		 */		public function grabItem(targetItem:Sprite):Sprite		{						if (newElementToBeDropped == null)			{								// Nothing is being dragged								// Start dragging selected element				newElementToBeDropped = targetItem;				stage.addChild(newElementToBeDropped);				newElementToBeDropped.x = stage.mouseX;				newElementToBeDropped.y = stage.mouseY;				newElementToBeDropped.startDrag();								// Watch when it is let go				stage.addEventListener(MouseEvent.MOUSE_UP, onNewElementMouseUp);								// event				dispatchEvent(new DrawingBoardEvent(DrawingBoardEvent.MOUSE_GRAB, false, false, newElementToBeDropped));							}			else			{								throw new Error("Only 1 item can be dragged by mouse.");							}						return newElementToBeDropped;					}				//--------------------------------------------------------------------------		//		//  Private methods		//		//--------------------------------------------------------------------------				private function createNewLayerAndSelectIt():void		{						// Select top most layer			var existingDrawingLayers:Vector.<IDrawingLayer> = getDrawingLayers();			var numLayers:int = existingDrawingLayers.length;						if ((existingDrawingLayers != null) && (numLayers > 0))				selectedLayer = existingDrawingLayers[numLayers - 1];			else				selectedLayer = addLayer(new DrawingLayer()); // or create new layer on the drawing board if there are no layers yet					}				/**		 * Sets mouseEnabled state on each layer depending on <code>selectMode</code> and <code>selectedLayer</code>.		 * 		 */		private function setLayerMouseState():void		{						var allLayers:Vector.<IDrawingLayer> = getDrawingLayers();			var numLayers:int = allLayers.length;			for (var i:int = 0; i < numLayers; i++)			{								if (selectMode)				{										// If selectMode, disable mouse on all layers except selectedLayer					if (allLayers[i] != selectedLayer)						allLayers[i].mouseEnabled = false;					else						allLayers[i].mouseEnabled = true;									}				else				{										// If !selectMode, enable mouse on all layers so they can be drawn					allLayers[i].mouseEnabled = true;									}							}					}				//--------------------------------------------------------------------------		//		//  Event handlers		//		//--------------------------------------------------------------------------				private function onLayerClickSelectItem(event:MouseEvent):void		{						if (selectMode &&				(selectTool != null) &&				(event.target is DisplayObject))			{								//trace(event.target+" "+event.target["name"]+" "+event.currentTarget.mouseX+" "+event.currentTarget.mouseY);								if (!(event.target is Image_SelectionTool))				{										if (event.target != event.currentTarget)					{												// Select specific object inside a layer						var targetItem:DisplayObject = event.target as DisplayObject;						while (targetItem.parent != event.currentTarget)						{														targetItem = targetItem.parent;													}												if (!(targetItem is Image_SelectionTool))						{														// Select this item							selectTool.target = targetItem;														if (imageMouseDragEnabled && selectTool.target)								somethingWasJustSelectedWithMouse = true; // Just selected something													}											}					else					{												// Clicked object is same as layer...?						// Must have clicked on non-Interactive Object, most likely Bitmap item												// TODO						// Look for clicked Bitmap item and select it						/*						var targetLayer:IDrawingLayer = event.currentTarget as IDrawingLayer;						var layerItems:Array = targetLayer.getChildren();						var numItemsInLayer:int = layerItems.length;						for (var i:int = 0; i < numItemsInLayer; i++)						{														if (layerItems[i] is Bitmap)							{																selectTool.target = layerItems[i];								break;															}													}						*/											}									}							}					}				/**		 * Event handler executed when <code>selectTool</code> selects a target.		 * @param event		 * 		 */		private function onImageSelect(event:ImageSelectionToolEvent):void		{						dispatchEvent(event.clone());					}				//--------------------------------------------------------------------------		//		//  Event handlers for mouse interaction		//		//--------------------------------------------------------------------------				private function onNewElementMouseUp(event:MouseEvent):void		{						// Stop dragging new element			var targetNewElement:Sprite = event.currentTarget as Sprite;			stage.removeEventListener(event.type, arguments.callee);						newElementToBeDropped.stopDrag();			stage.removeChild(newElementToBeDropped);						var dropPointCoord:Point = globalToLocal(new Point(stage.mouseX, stage.mouseY));			if ((0 <= dropPointCoord.x) && (dropPointCoord.x <= canvasSize.width) &&				(0 <= dropPointCoord.y) && (dropPointCoord.y <= canvasSize.height))			{								// If new element was dropped on top of drawing board, place it				forceDraw = true;				drawItemAt(newElementToBeDropped, dropPointCoord.x, dropPointCoord.y);				forceDraw = false;								// Select item that was just dropped				if (selectMode && (selectTool != null))					selectTool.target = newElementToBeDropped;								somethingWasJustSelectedWithMouse = false;								// event				dispatchEvent(new DrawingBoardEvent(DrawingBoardEvent.MOUSE_DROP, false, false,					newElementToBeDropped,					null,					selectedLayer,					new Point(dropPointCoord.x, dropPointCoord.y)));							}			else			{								// Dropped outside of the drawing board								// event				dispatchEvent(new DrawingBoardEvent(DrawingBoardEvent.MOUSE_DROP_MISS, false, false,					newElementToBeDropped,					null,					null,					new Point(dropPointCoord.x, dropPointCoord.y)));							}						newElementToBeDropped = null;					}				private function drawArea_mouseDownHandler(event:MouseEvent):void		{						if (selectMode && (selectTool != null))			{								if ((event.target == selectTool.target) || (event.target == selectTool))					somethingWasJustSelectedWithMouse = true; // Just mouse downed on something that is already selected				else if (event.target == this)					selectTool.target = null;// Deselect							}					}				private function drawArea_mouseUpHandler(event:MouseEvent):void		{						somethingWasJustSelectedWithMouse = false;					}				private function drawArea_mouseMoveHandler(event:MouseEvent):void		{						if (selectMode &&				(selectTool != null) &&				(selectTool.target != null) &&				somethingWasJustSelectedWithMouse &&				event.buttonDown)			{								// Something was just selected and user still has button down								// So pick it up				grabItem(selectTool.target as Sprite);								// deselect				selectTool.target = null;								somethingWasJustSelectedWithMouse = false;							}					}			}	}