/** * This Source Code Form is subject to the terms of the Mozilla Public * License, v. 2.0. If a copy of the MPL was not distributed with this file, * You can obtain one at http://mozilla.org/MPL/2.0/. *  * Copyright (c) 2014 Kaoru Kawashima @altoinu http://altoinu.com */package com.altoinu.flash.simplephysicsengine.controllers{		import com.altoinu.flash.datamodels.Acceleration;	import com.altoinu.flash.datamodels.Velocity;	import com.altoinu.flash.simplephysicsengine.events.SimplePhysicsControllerEvent;	import com.altoinu.flash.simplephysicsengine.events.SimplePhysicsObject3DEvent;	import com.altoinu.flash.simplephysicsengine.models.SimplePhysicsHitTestElements;	import com.altoinu.flash.simplephysicsengine.objects.ISimplePhysicsObject3D;		import flash.events.EventDispatcher;
		/**	 * Event dispatched every time physics is applied.	 * 	 * @eventType com.altoinu.flash.simplephysicsengine.events.SimplePhysicsControllerEvent.APPLIED	 */	[Event(name="accelerated", type="com.altoinu.flash.simplephysicsengine.events.SimplePhysicsControllerEvent")]		/**	 * Class controlling all physics happening within the simple physics.	 * 	 * <p>TODO for future: elastic and inelastic collisions	 * http://en.wikipedia.org/wiki/Momentum#Elastic_collisions</p>	 * 	 * @author kaoru.kawashima	 * 	 */	public class SimplePhysicsController extends EventDispatcher	{				//--------------------------------------------------------------------------		//		//  Class variable		//		//--------------------------------------------------------------------------				/**		 * @private		 */				private static var _controller:SimplePhysicsController;				//--------------------------------------------------------------------------		//		//  Class methods		//		//--------------------------------------------------------------------------				/**		 * @private		 */				private static function hidden():void {}				/**		 * Returns reference to an instance of a singleton.		 * @return 		 * 		 */		public static function getInstance():SimplePhysicsController		{						if(!_controller)				_controller = new SimplePhysicsController();						return _controller;					}				//--------------------------------------------------------------------------		//		//  Constructor		//		//--------------------------------------------------------------------------				/**		 * Constructor.		 * @param target		 * 		 */		public function SimplePhysicsController()		{						super();					}				//--------------------------------------------------------------------------		//		//  Properties		//		//--------------------------------------------------------------------------				/**		 * Gravity used in this physics calculation.  Default is Acceleration(0, -0.0980665, 0),		 * which is the Earth's gravitational acceleration.		 */		public var gravity:Acceleration = new Acceleration(0, -0.00980665, 0);				/**		 * Enable/Disable physics engine.		 */		public var enabled:Boolean = true;				//--------------------------------------------------------------------------		//		//  Methods		//		//--------------------------------------------------------------------------				/**		 * Applies physics to the Objects in the Array.  If <code>enabled</code> property		 * is set to false, then this method will have no effect.		 * 		 * @param targetObjects Array of ISimplePhysicsObject3D. Any objects that is not ISimplePhysicsObject3D is ignored.		 * @param millisecondsElapsed Milliseconds passed since last apply.  This value is used to calculate		 * how much to translate each object based on its velocity values.  For example, if an object has velocity		 * of (1, 0, 0) it means it will move 1 unit in x direction every milliseconds, so if <code>millisecondsElapsed</code>		 * is set to 500, this object is moved 500 units.		 * 		 */		public function apply(targetObjects:Array, millisecondsElapsed:int):void		{						if (enabled)			{								var checkForCollisionObjects:Vector.<PhysicsValues> = new Vector.<PhysicsValues>();								// Move targetObjects using velocity and gravity				var currentTargetObject:ISimplePhysicsObject3D;				var appliedPhysics:PhysicsValues;				var numObjects:uint = targetObjects.length;				for (var i:int = 0; i < numObjects; i++)				{										if ((targetObjects[i] is ISimplePhysicsObject3D) && (ISimplePhysicsObject3D(targetObjects[i]).enablePhysics))					{												currentTargetObject = targetObjects[i];												appliedPhysics = new PhysicsValues();						appliedPhysics.targetObject = currentTargetObject;						appliedPhysics.oldVelocity = appliedPhysics.targetObject.velocity.clone() as Velocity;												// Calculate total acceleration applied to the object						appliedPhysics.totalAcceleration = appliedPhysics.targetObject.acceleration.clone() as Acceleration;												if ((appliedPhysics.targetObject.enableExternalForce) &&							(gravity != null))						{														// Apply gravity to the velocity							appliedPhysics.totalAcceleration.x += gravity.x;							appliedPhysics.totalAcceleration.y += gravity.y;							appliedPhysics.totalAcceleration.z += gravity.z;													}												// Move object to new position and accelerate						appliedPhysics.targetObject.move(millisecondsElapsed, appliedPhysics.totalAcceleration);												// Remember updated velocity						appliedPhysics.newVelocity = appliedPhysics.targetObject.velocity.clone() as Velocity;												if (currentTargetObject.enableCollisionReaction)							checkForCollisionObjects.push(appliedPhysics);											}									}								var againstObj:ISimplePhysicsObject3D;				var collisionTracker:CollidedObjectsTracker = new CollidedObjectsTracker();				var physValues:PhysicsValues;				var hitTestElements:SimplePhysicsHitTestElements;				var collideEvent:SimplePhysicsObject3DEvent;				var numItems:int = checkForCollisionObjects.length;				for (i = 0; i < numItems; i++)				{										// Now that all targetObjects are moved to new position, check for collision					physValues = checkForCollisionObjects[i];					currentTargetObject = physValues.targetObject;					if (currentTargetObject.enableCollision)					{												// Check for collision against all other ISimplePhysicsObject3D						for (var j:uint = 0; j < numObjects; j++)						{														if (targetObjects[j] is ISimplePhysicsObject3D)							{																againstObj = targetObjects[j];																if ((currentTargetObject != againstObj) &&									againstObj.enableCollision &&									(collisionTracker.isColliding(currentTargetObject, againstObj) != null))								{																		//currentTargetObject collided into some other againstObj (ISimplePhysicsObject3D)																		hitTestElements = collisionTracker.isColliding(currentTargetObject, againstObj);																		collideEvent = new SimplePhysicsObject3DEvent(SimplePhysicsObject3DEvent.COLLIDED, false, false,																				  physValues.oldVelocity,																				  physValues.newVelocity,																				  physValues.totalAcceleration,																				  againstObj,																				  hitTestElements.currentTargetHitAreas.concat(),																				  hitTestElements.collidedTargetHitAreas.concat());																		currentTargetObject.dispatchEvent(collideEvent);																	}															}													}												// TODO: This would be a good spot to do elastic and inelastic collisions											}									}								dispatchEvent(new SimplePhysicsControllerEvent(SimplePhysicsControllerEvent.APPLIED, false, false));								// TODO: collisionTracker needs to be cleaned out here to prevent memory leak							}					}			}	}import com.altoinu.flash.datamodels.Acceleration;
import com.altoinu.flash.datamodels.Velocity;
import com.altoinu.flash.simplephysicsengine.models.SimplePhysicsHitTestElements;
import com.altoinu.flash.simplephysicsengine.objects.ISimplePhysicsObject3D;

import flash.utils.Dictionary;
class PhysicsValues{		public function PhysicsValues():void {}		public var targetObject:ISimplePhysicsObject3D;	public var oldVelocity:Velocity;	public var newVelocity:Velocity;	public var totalAcceleration:Acceleration;	
}class CollidedObjectsTracker{		public function CollidedObjectsTracker():void	{				collidedObj = new Dictionary();			}		private var collidedObj:Dictionary;		/**	 * Track objects that collided into target1.	 * @param target1	 * @param target2	 * 	 */	public function add(target1:ISimplePhysicsObject3D, target2:ISimplePhysicsObject3D, hitTestElements:SimplePhysicsHitTestElements):void	{				if (collidedObj[target1] == null)			collidedObj[target1] = new Dictionary();				if (collidedObj[target1][target2] == null)			collidedObj[target1][target2] = hitTestElements;			}		/**	 * Check to see if target1 and target2 are colliding.	 * @param target1	 * @param target2	 * @return 	 * 	 */	public function isColliding(target1:ISimplePhysicsObject3D, target2:ISimplePhysicsObject3D):SimplePhysicsHitTestElements	{				var index:int;				if ((collidedObj[target1] != null) && (collidedObj[target1][target2] != null))		{						return collidedObj[target1][target2];					}		else		{						var collided:SimplePhysicsHitTestElements = ISimplePhysicsObject3D(target1).isColliding(target2);						// Remember these objects if they collided so we do not have to call the actual			// isColliding method next time around to save CPU usage			if (collided != null)			{								add(target1, target2, collided);								var opposite:SimplePhysicsHitTestElements = new SimplePhysicsHitTestElements(collided.collidedTargetHitAreas.concat(), collided.currentTargetHitAreas.concat());				add(target2, target1, opposite);							}						return collided;					}			}	
}